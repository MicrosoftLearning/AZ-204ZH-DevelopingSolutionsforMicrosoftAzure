---
lab:
    az204Title: 'Lab 03: 使用适用于 .NET 的 Azure 存储 SDK 检索 Azure 存储资源和元数据'
    az020Title: 'Lab 03: 使用适用于 .NET 的 Azure 存储 SDK 检索 Azure 存储资源和元数据'
    az204Module: 'Module 03: 开发使用 Blob 存储的解决方案'
    az020Module: 'Module 03: 开发使用 Blob 存储的解决方案'
---

# 实验室 03：使用适用于 .NET 的 Azure 存储 SDK 检索 Azure 存储资源和元数据
# 学生实验室手册

## 实验室场景

你正准备在 Microsoft Azure 中托管一个结合使用光栅和矢量图形的 Web 应用程序。作为开发小组，你的团队决定将多媒体内容都存储在 Azure 存储中，并通过使用 .NET 中的 C# 代码以自动化的方式对其进行管理。在开始这一重要里程碑之前，你已经决定花些时间来学习最新版本的 .NET SDK，通过创建用于管理和枚举 Blob 和容器的简单应用程序来访问存储。

## 目标

完成本实验室后，你将能够：

-   通过使用 Azure 门户创建容器和上传 Blob。

-   使用适用于 .NET 的 Microsoft Azure 存储 SDK 枚举 Blob 和容器。

-   使用存储 SDK 提取 Blob 元数据。

## 实验室设置

-   预计用时：**45 分钟**

## 说明

### 准备工作

#### 登录到实验室虚拟机

请确保你已使用以下凭据登录到你的 Windows 10 虚拟机：
    
-   用户名：**Admin**

-   密码：**Pa55w.rd**

#### 查看已安装的应用程序

在你的 Windows 10 桌面上找到任务栏。任务栏里有本实验室中你将使用的应用程序的图标：

-   Microsoft Edge

-   文件资源管理器

### 练习 1：创建 Azure 资源

#### 任务 1：打开 Azure 门户

1.  登录到 Azure 门户 (<https://portal.azure.com>)。

1.  如果这是你第一次登录 Azure 门户，你将会看到一个提供门户导览的对话框。选择 **“开始”** 跳过导览。

#### 任务 2：创建存储帐户

1.  使用以下详细信息创建新的存储帐户：
    
    -    新建资源组：**StorageMedia**

    -    名称： **mediastor*[yourname]***

    -    位置： **美国东部**

    -    性能： **标准**

    -    帐户类型：**StorageV2（常规用途 v2）**

    -    复制：**读取访问异地冗余存储 (RA-GRS)**

    > **备注**： 等待 Azure 完成创建存储帐户后，再继续执行本实验室。你将在帐户创建完毕后收到通知。

1.  打开新创建的存储帐户实例的 **“属性”** 部分。

1.  将值记录在 **“主 Blob 服务终结点”** 文本框中。你稍后将在本实验室中使用此值。

1.  打开存储帐户实例的 **“访问密钥”** 部分。

1.  将值记录在 **“存储帐户名称”** 文本框和任何 **“密钥”** 文本框中。你将在本实验室的后面部分使用这些值。

#### 回顾

在本练习中，你创建了将用于本实验室其余部分的新存储帐户。

### 练习 2： 将 Blob 上传到容器

#### 任务 1：创建存储帐户容器

1.  访问之前在本实验室中创建的 **mediastor*[yourname]*** 存储帐户。

1.  选择 **“Blob 服务”** 部分中的 **“容器”** 链接，然后使用以下设置创建新容器：
    
    -    名称： **raster-graphics**

    -    公共访问级别：**专用（禁止匿名访问）**

1.  选择 **“Blob 服务”** 部分中的 **“容器”** 链接，然后使用以下设置创建新容器：
    
    -    名称： **compressed-audio**

    -    公共访问级别：**专用（禁止匿名访问）**

1.  查看更新后的容器列表。

#### 任务 2：上传存储帐户 Blob

1.  访问之前在本实验室中创建的 **mediastor*[yourname]*** 存储帐户。

1.  在 **“Blob 服务”** 部分中选择 **“容器”** 链接，然后选择最近创建的 **raster-graphics** 容器。
    
1.  在 **raster-graphics** 容器中，选择 **“上传”** 以上传 **graph.jpg** 文件，该文件位于实验室 VM 上的 **Allfiles (F): \\Allfiles\\Labs\\03\\Starter\\Images** 文件夹中。

    > **备注**：建议启用 **“如果文件已存在，请覆盖”** 选项。 

#### 回顾

在本练习中，你在存储帐户中创建了几个占位符容器，并在其中一个容器中填充了一个 Blob。

### 练习 3： 使用 .NET SDK 访问容器

#### 任务 1：创建 .NET 项目

1.  在 Visual Studio Code 中，打开 **Allfiles (F):\\Allfiles\\Labs\\03\\Starter\\BlobManager** 文件夹。

1.  使用终端在当前文件夹中创建一个名为 **BlobManager** 的新 .NET 项目：

    ```
    dotnet new console --name BlobManager --output .
    ```

    > **备注**： **dotnet new** 命令将在与项目同名的文件夹中创建一个新的 **“控制台”** 项目。

1.  使用同一终端从 NuGet 导入 12.0.0 版本的 **Azure.Storage.Blobs**：

    ```
    dotnet add package Azure.Storage.Blobs --version 12.0.0
    ```

    > **备注**： **dotnet add package** 命令将从 NuGet 添加 **Azure.Storage.Blobs** 包。有关详细信息，请转到 [Azure.Storage.Blobs](https://www.nuget.org/packages/Azure.Storage.Blobs/12.0.0)。

1.  使用同一终端构建 .NET Web 应用程序：

    ```
    dotnet build
    ```

1.  关闭当前终端。

#### 任务 2：修改程序类以访问存储

1.  在 Visual Studio Code 中打开 **Program.cs** 文件。

1.  删除 **Program.cs** 文件中的所有现有代码。

1.  为应用程序将引用的库添加以下 **using** 指令：

    ```
    using Azure.Storage;
    using Azure.Storage.Blobs;
    using Azure.Storage.Blobs.Models;
    using System;
    using System.Threading.Tasks;
    ```

1.  创建一个新的 **Program** 类，并为其设置 **blobServiceEndpoint**、**storageAccountName** 和 **storageAccountKey** 三个常量字符串属性，然后创建一个异步 **Main** 入口点方法：

    ```
    public class Program
    {
        private const string blobServiceEndpoint = "";
        private const string storageAccountName = "";
        private const string storageAccountKey = "";
        
        public static async Task Main(string[] args)
        {
        }
    }
    ```

1.  通过将 **blobServiceEndpoint** 字符串常量的值设置为之前在本实验室中记录的存储帐户的 **“主 Blob 服务终结点”** 来更新该字符串常量。

1.  通过将 **storageAccountName** 字符串常量的值设置为之前在本实验室中记录的存储帐户的**存储帐户名称**来更新该字符串常量。

1.  通过将 **storageAccountKey** 字符串常量的值设置为之前在本实验室中记录的存储帐户的密**钥**来更新该字符串常量。

#### 任务 3：连接到 Azure 存储 Blob 服务终结点

1.  在 **Main** 方法中，添加以下代码块以连接到存储帐户并检索帐户元数据：

    ```
    StorageSharedKeyCredential accountCredentials = new StorageSharedKeyCredential(storageAccountName, storageAccountKey);

    BlobServiceClient serviceClient = new BlobServiceClient(new Uri(blobServiceEndpoint), accountCredentials);

    AccountInfo info = await serviceClient.GetAccountInfoAsync();
    ```

1.  仍在 **Main** 方法中，添加以下代码块以打印有关存储帐户的元数据：

    ```
    await Console.Out.WriteLineAsync($"Connected to Azure Storage Account");
    await Console.Out.WriteLineAsync($"Account name:\t{storageAccountName}");
    await Console.Out.WriteLineAsync($"Account kind:\t{info?.AccountKind}");
    await Console.Out.WriteLineAsync($"Account sku:\t{info?.SkuName}");
    ```

1.  保存 **Program.cs** 文件。

1.  使用终端，运行控制台应用程序项目：

    ```
    dotnet run
    ```

    > **备注**：如果出现任何生成错误，请查看位于 **Allfiles (F):\\Allfiles\\Labs\\03\\Solution\\BlobManager** 文件夹中的 **Program.cs** 文件。

1.  观察当前运行的控制台应用程序的输出。输出包含从服务中检索到的存储帐户的元数据。

1.  关闭当前终端。

#### 任务 4：枚举现有容器

1.  在 **Program** 类中，创建一个新的名为 **EnumerateContainersAsync** 的**私有静态**方法，该方法是异步的，并且具有一个类型为 **BlobServiceClient** 的参数：

    ```
    private static async Task EnumerateContainersAsync(BlobServiceClient client)
    {        
    }
    ```

1.  在 **EnumerateContainersAsync** 方法中，创建一个异步 **foreach** 循环，该循环遍历 **BlobServiceClient** 类的 **GetBlobContainersAsync** 方法的调用结果，并在屏幕上显示出每个容器的名称：

    ```
    await foreach (BlobContainerItem container in client.GetBlobContainersAsync())
    {
        await Console.Out.WriteLineAsync($"Container:\t{container.Name}");
    }
    ```

1.  在 **Main** 方法中，添加一行新代码以调用 **EnumerateContainersAsync** 方法，传入 *serviceClient* 变量作为参数：

    ```
    await EnumerateContainersAsync(serviceClient);
    ```

1.  保存 **Program.cs** 文件。

1.  使用终端，运行控制台应用程序项目：

    ```
    dotnet run
    ```

    > **备注**：如果出现任何生成错误，请查看位于 **Allfiles (F):\\Allfiles\\Labs\\03\\Solution\\BlobManager** 文件夹中的 **Program.cs** 文件。

1.  观察当前运行的控制台应用程序的输出。更新后的输出包括帐户中每个现有容器的列表。

1.  关闭当前终端。

#### 回顾

在本练习中，你通过使用存储 SDK 访问了现有容器。 

### 练习 4：使用 .NET SDK 检索 Blob 统一资源标识符 (URI)

#### 任务 1：使用 SDK 枚举现有容器中的 Blob

1.  在 **Program** 类中，创建一个新的名为 **EnumerateBlobsAsync** 的**私有静态**方法，该方法是异步的，并且具有两种类型的参数 **BlobServiceClient** 和 **string**：

    ```
    private static async Task EnumerateBlobsAsync(BlobServiceClient client, string containerName)
    {      
    }
    ```

1.  在 **EnumerateBlobsAsync** 方法中，通过使用 **BlobServiceClient** 类的 **GetBlobContainerClient** 方法获取 **BlobContainerClient** 的新实例，从而传入 **containerName** 参数：

    ```
    BlobContainerClient container = client.GetBlobContainerClient(containerName);
    ```

1.  在 **EnumerateBlobsAsync** 方法中，呈现将被枚举的容器的名称：

    ```
    await Console.Out.WriteLineAsync($"Searching:\t{container.Name}");
    ```

1.  在 **EnumerateBlobsAsync** 方法中，创建一个异步 **foreach** 循环，该循环对 **BlobContainerClient** 类的 **GetBlobsAsync** 方法的调用结果进行循环访问，并打印出每个 Blob 的名称：

    ```
    await foreach (BlobItem blob in container.GetBlobsAsync())
    {
        await Console.Out.WriteLineAsync($"Existing Blob:\t{blob.Name}");
    }
    ```

1.  在 **Main** 方法中，添加一行新代码以创建一个名为 *existingContainerName* 且值为 **raster-graphics** 的变量：

    ```
    string existingContainerName = "raster-graphics";
    ```

1.  在 **Main** 方法中，添加一行新代码以调用 **EnumerateBlobsAsync** 方法，从而以参数的形式传入 *serviceClient* 和 *existingContainerName* 变量：

    ```
    await EnumerateBlobsAsync(serviceClient, existingContainerName);
    ```

1.  保存 **Program.cs** 文件。

1.  使用终端，运行控制台应用程序项目：

    ```
    dotnet run
    ```

    > **备注**：如果出现任何生成错误，请查看位于 **Allfiles (F):\\Allfiles\\Labs\\03\\Solution\\BlobManager** 文件夹中的 **Program.cs** 文件。

1.  观察当前运行的控制台应用程序的输出。更新后的输出包括有关现有容器和 Blob 的元数据。

1.  关闭当前终端。

#### 任务 2： 使用 SDK 创建新容器

1.  在 **Program** 类中，创建一个新的名为 **GetContainerAsync** 的**私有静态**方法，该方法是异步的，并且具有两种参数类型 **BlobServiceClient** 和 **string**：

    ```
    private static async Task<BlobContainerClient> GetContainerAsync(BlobServiceClient client, string containerName)
    {      
    }
    ```

1.  在 **GetContainerAsync** 方法中，通过使用 **BlobServiceClient** 类的 **GetBlobContainerClient** 方法获取 **BlobContainerClient** 类的新实例，传入 **containerName** 参数。调用 **BlobContainerClient** 类的 **CreateIfNotExistsAsync** 方法：

    ```
    BlobContainerClient container = client.GetBlobContainerClient(containerName);
    await container.CreateIfNotExistsAsync(PublicAccessType.Blob);
    ```

1.  在 **GetContainerAsync** 方法中，呈现可能创建的容器的名称：

    ```
    await Console.Out.WriteLineAsync($"New Container:\t{container.Name}");
    ```

1.  返回名为 **container** 的 **BlobContainerClient** 类的实例作为 **GetContainerAsync** 方法的结果：

    ```
    return container;
    ``` 
    
1.  在 **Main** 方法中，添加一行新代码以创建一个名为 *newContainerName* 且值为 **vector-graphics** 的变量：

    ```
    string newContainerName = "vector-graphics";
    ```

1.  在 **Main** 方法中，添加一行新代码以调用 **GetContainerAsyn** 方法，以参数的形式传入 *serviceClient* 和 *newContainerName* 变量：

    ```
    BlobContainerClient containerClient = await GetContainerAsync(serviceClient, newContainerName);
    ```

1.  保存 **Program.cs** 文件。

1.  使用终端，运行控制台应用程序项目：

    ```
    dotnet run
    ```

    > **备注**：如果出现任何生成错误，请查看位于 **Allfiles (F):\\Allfiles\\Labs\\03\\Solution\\BlobManager** 文件夹中的 **Program.cs** 文件。

1.  观察当前运行的控制台应用程序的输出。更新后的输出包括有关新容器和 Blob 的元数据。

1.  关闭当前终端。

#### 任务 3：使用门户上传新 Blob

1.  访问之前在本实验室中创建的 **mediastor*[yourname]*** 存储帐户。

1.  选择 **“Blob 服务”** 部分的 **“容器”** 链接，然后选择新创建的 **“vector-graphics”** 容器。
    
1.  在 **“vector-graphics”** 容器中，选择 **“上传”** 以上传 **graph.svg** 文件，该文件位于实验室 VM 上的 **Allfiles (F): \\Allfiles\\Labs\\03\\Starter\\Images** 文件夹中。

    > **备注**：建议启用 **“如果文件已存在，请覆盖”** 选项。 

#### 任务 4：使用 SDK 访问 Blob URI

1.  在 **Program** 类中，创建一个新的名为 **GetBlobAsync** 的**私有静态**方法，该方法是异步的，并且具有两种类型的参数 **BlobContainerClient** 和 **string**：

    ```
    private static async Task<BlobClient> GetBlobAsync(BlobContainerClient client, string blobName)
    {      
    }
    ```

1.  在 **GetBlobAsync** 方法中，通过使用 **BlobContainerClient** 类的 **GetBlobClient** 方法获取 **BlobClient** 类的新实例，传入 **blobName** 参数：

    ```
    BlobClient blob = client.GetBlobClient(blobName);
    ```

1.  在 **GetBlobAsync** 方法中，呈现引用的 Blob 的名称：

    ```
    await Console.Out.WriteLineAsync($"Blob Found:\t{blob.Name}");
    ```

1.  返回名为 **blob** 的 **BlobClient** 类的实例作为 **GetBlobAsync** 方法的结果：

    ```
    return blob;
    ```  
    
1.  在 **Main** 方法中，添加一行新代码以创建一个名为 *uploadedBlobName* 且值为 **vector-graphics** 的变量：

    ```
    string uploadedBlobName = "graph.svg";
    ```

1.  在 **Main** 方法中，添加一行新代码以调用 **GetBlobAsync** 方法，从而以参数的形式传入 *containerClient* 和 *uploadedBlobName* 变量并将结果存储在类型 **BlobClient** 的名为 *blobClient* 的变量中：

    ```
    BlobClient blobClient = await GetBlobAsync(containerClient, uploadedBlobName);
    ```

1.  在 **Main** 方法中，添加一行新代码以呈现 *blobClient* 变量的 **Uri** 属性：

    ```
    await Console.Out.WriteLineAsync($"Blob Url:\t{blobClient.Uri}");
    ```

1.  保存 **Program.cs** 文件。

1.  使用终端，运行控制台应用程序项目：

    ```
    dotnet run
    ```

    > **备注**：如果出现任何生成错误，请查看位于 **Allfiles (F):\\Allfiles\\Labs\\03\\Solution\\BlobManager** 文件夹中的 **Program.cs** 文件。

1.  观察当前运行的控制台应用程序的输出。更新后的输出包括在线访问 Blob 的最终 URL。记录本 URL 的值，以便稍后在本实验室中使用。

    > **备注**：该 URL 可能类似于以下字符串：**https://mediastor*[yourname]*.blob.core.windows.net/vector-graphics/graph.svg**

1.  关闭当前终端。
    
#### 任务 5：使用浏览器测试该 URI

1.  使用新的浏览器窗口或选项卡，转到该 Blob 的 URL 并查找 Blob 的内容。 

1.  现在，应该在浏览器窗口中注意到可缩放矢量图形 (SVG) 文件。

#### 回顾

在本练习中，你使用存储 SDK 创建了容器并管理了 Blob。 

### 练习 5：清理订阅 

#### 任务 1：打开 Azure Cloud Shell 并列出资源组

1.  在 Azure 门户中，选择 **“Cloud Shell”** 图标以打开一个新的 shell 实例。

1.  如果尚未配置 **Cloud Shell**，请使用默认设置为 **Bash** 配置 shell。

#### 任务 2：删除资源组

1.  输入以下命令，然后按 Enter 以删除 **“StorageMedia”** 资源组：

    ```
    az group delete --name StorageMedia --no-wait --yes
    ```
    
1.  关闭门户中的 Cloud Shell 窗格。

#### 任务 3：关闭活动的应用程序

1.     当前正在运行的 Microsoft Edge 应用程序。

#### 回顾

在本练习中，你通过删除本实验室中曾经使用的资源组来清理订阅。
